# Kali - Voice Game Moderator

## Project Overview

Kali is a voice-first PWA game moderator for kids to play board games independently. Currently supports Snakes & Ladders, with a vision to become a game-agnostic engine.

## Vision: LLM-Assisted Game Creation

The long-term goal is a system where:
- Users feed game rules and context to an LLM service/endpoint
- LLM generates game definition JSON (rules, state schema, primitives)
- Human validates and uploads to engine (S3/repo/JSON storage)
- New games become instantly available to Kali
- Enables complex games (D&D and beyond) without code changes

## Core Architecture: The CPU and the Game Designer

The system is built on a strict separation of duties:

### The LLM (Game Designer)
- Creative but untrusted component
- Reads game rules and understands player intent
- Translates high-level concepts into primitive action sequences
- All game-specific logic lives in the LLM context

### The Orchestrator (CPU)
- Deterministic, authoritative, and simple component
- Knows nothing about game rules
- Only understands primitive actions: `READ_STATE`, `WRITE_STATE`, `ROLL_DICE`, `NARRATE`
- Validates and executes instructions from the LLM
- Guarantees game state integrity

This separation ensures the Orchestrator stays small and universal.

## State Management Axioms - CRITICAL ARCHITECTURE

These are ABSOLUTE rules that must NEVER be violated:

### 1. Orchestrator Authority (THE CPU MODEL)

**The orchestrator is the sole authority for ALL game state mutations.**

✅ CORRECT:
- Orchestrator methods: `setupPlayers()`, `transitionPhase()`, `advanceTurn()`
- Primitive execution within orchestrator: `SET_STATE`, `PLAYER_ROLLED`, etc.
- Orchestrator internal state updates: board moves, square effects

❌ FORBIDDEN:
- App layer directly calling `stateManager.set()`
- UI components directly calling `stateManager.set()`
- NameCollector or similar components mutating state
- Any component bypassing orchestrator to change game state

### 2. Phase Transitions - ORCHESTRATOR ONLY, NEVER LLM

**Phase transitions (SETUP → PLAYING → FINISHED) are orchestrator-owned.**

✅ CORRECT:
- `orchestrator.transitionPhase(GamePhase.PLAYING)`
- Orchestrator decides when to transition based on game state

❌ FORBIDDEN:
- LLM requesting phase transitions via primitives
- App layer directly setting `game.phase`
- UI components setting `game.phase`
- New primitive actions for phase control (phases are NOT user-facing)

**Rationale**: Phases are internal state machine transitions, not game actions.

### 3. Turn Advancement - ORCHESTRATOR ONLY, NEVER LLM

**Turn advancement is orchestrator-owned automatic behavior.**

✅ CORRECT:
- `orchestrator.advanceTurn()` - returns next player data
- App layer announces turn change to user
- Orchestrator blocks turns during effects/decisions

❌ FORBIDDEN:
- LLM requesting turn advancement via primitives
- App layer directly setting `game.turn`
- Manual `SET_STATE` on `game.turn` (validator blocks this)
- Bypassing orchestrator's turn logic

**Rationale**: Turn advancement has complex rules (effects, decisions, win conditions).

### 4. UI Components Return Data, Never Mutate State

**UI components collect data and return it. State mutations go through orchestrator.**

✅ CORRECT:
- `nameCollector.collectNames()` returns `string[]`
- Caller: `orchestrator.setupPlayers(names)`
- Component has no stateManager dependency

❌ FORBIDDEN:
- UI component with stateManager in constructor
- UI component calling `stateManager.set()`
- UI component mixing presentation with state mutations

**Pattern**: Collect → Return → Orchestrator Applies

### 5. App Layer is Pure Coordination

**KaliAppCore wires components and coordinates flow. NO game logic.**

✅ CORRECT:
- Initialize components
- Delegate to orchestrator for state changes
- Announce results to user (TTS)
- Handle user input routing

❌ FORBIDDEN:
- App layer implementing game mechanics
- App layer deciding turn advancement logic
- App layer managing phase transitions
- App layer duplicating orchestrator logic

### 6. StateManager is Infrastructure, Not Policy

**StateManager provides storage. Orchestrator provides policy.**

✅ CORRECT:
- StateManager has public `set()` for flexibility
- Access control enforced at orchestrator level
- Only orchestrator calls `set()` during gameplay

❌ FORBIDDEN:
- Adding orchestrator checks inside StateManager
- Making StateManager "smart" about game rules
- Coupling StateManager to game logic

**Rationale**: Keep infrastructure layer simple and reusable.

## Enforcement

### Code Review Checklist
- [ ] Any `stateManager.set()` call must be in orchestrator or justified
- [ ] New UI components must not have stateManager dependency
- [ ] Phase transitions go through `orchestrator.transitionPhase()`
- [ ] Turn advancement goes through `orchestrator.advanceTurn()`
- [ ] LLM primitives do NOT include phase or turn control

### Testing Requirements
- New features that manage state must have orchestrator tests
- UI components must have tests proving they don't mutate state
- Integration tests must verify orchestrator authority

### Architectural Violations are Critical Bugs
If you find code that violates these axioms, it is a **CRITICAL bug** that must be fixed immediately, regardless of whether it "works."

## Technology Stack

- **Platform**: Progressive Web App (PWA) with screen always on
- **Language**: TypeScript (ES2022, strict mode)
- **Build Tool**: Vite
- **Audio Pipeline**: WebAudio API + AudioWorklet
- **Speech Recognition**: Vosk (fully offline, wake word + STT)
- **LLM Clients**: Gemini (fast, recommended) or Ollama (local)
- **State Storage**: In-memory state management
- **TTS**: Browser SpeechSynthesis API
- **Sound Effects**: WebAudio for preloaded local audio
- **Caching**: Service Worker + Cache API for offline operation

## Key Patterns & Concepts

### Primitive Actions
The orchestrator only understands these primitives:
- `READ_STATE` - Read from game state
- `WRITE_STATE` - Write to game state
- `ROLL_DICE` - Generate random numbers
- `NARRATE` - Speak to players via TTS

### State Machine
Audio pipeline follows: idle → listening → processing → speaking

### Voice-Only UX
- Screen stays on but no visual interaction required
- All feedback must be audible
- Users cannot see errors, so voice feedback is critical

### LLM Swappability
- All LLM clients implement `ILLMClient` interface
- Switching providers is a one-line change

### Processing Lock
- Prevents overlapping LLM requests
- Ensures serial processing of voice commands

## Development Guidelines

- Write clean, canonical, and DRY code
- Avoid smart hacks, obscure patterns, or clever tricks
- Add comments ONLY when they add significant value
- Use strict TypeScript with all compiler warnings enabled
- Follow ESLint rules for code quality
- **After making code changes, always run `npm run lint` and `npm run type-check` and fix any issues**
- Add JSDoc comments to:
  - All public methods and functions
  - All exported interfaces, types, and classes
  - Complex private methods where the logic is non-obvious
- JSDoc should include:
  - Brief description of what the method/class does
  - @param tags for all parameters
  - @returns tag for return values
  - @throws tag if the method can throw errors

## Important File Locations

### Core Logic
- `src/orchestrator/` - Core validation and execution logic
  - `orchestrator.ts` - Main orchestration loop (refactored into subsystems)
  - `turn-manager.ts` - Turn advancement and ownership validation
  - `board-effects-handler.ts` - Board moves and square effects
  - `decision-point-enforcer.ts` - Decision point requirements
  - `validator.ts` - Primitive action validation
  - `types.ts` - Type definitions for primitives
  - `name-collector.ts` - Voice-based player name collection
- `src/llm/` - LLM clients and system prompts
  - `ILLMClient.ts` - Interface for LLM providers
  - `GeminiClient.ts` - Google Gemini integration
  - `OllamaClient.ts` - Local Ollama integration
  - `system-prompt.ts` - LLM system prompt generator

### Services
- `src/services/` - Speech and UI services
  - `speech-service.ts` - TTS and audio playback
  - `ui-service.ts` - UI service interface
  - `production-ui-service.ts` - Minimal pulsating orb UI
  - `debug-ui-service.ts` - Full debug console UI

### Audio Pipeline
- `src/audio-worklet/` - Audio processing for Vosk
  - `vosk-processor.js` - AudioWorklet processor
- `src/wake-word.ts` - Wake word detection state machine
- `src/model-manager.ts` - Vosk model downloading and caching

### Game System
- `src/game-loader/` - Game definition loading
  - `game-loader.ts` - Loads game JSON and sound effects
  - `types.ts` - Game definition types
- `public/games/` - Game definitions (JSON files)
  - Each JSON contains: name, rules, initialState, soundEffects

### State Management
- `src/state-manager.ts` - In-memory state manager with path-based operations

### Utilities
- `src/utils/` - Helper functions
  - `logger.ts` - Logging utility
  - `profiler.ts` - Performance profiling
  - `name-helper.ts` - Name transcription error correction
  - `deep-clone.ts` - Deep cloning utility

### Configuration & Entry Points
- `src/config.ts` - App configuration (wake word, timeouts, etc.)
- `src/main.ts` - Production app entry point
- `src/debug.ts` - Debug interface entry point
- `kali.md` - **Detailed project brief and todo list**

## Common Tasks

### Adding New Primitive Actions
1. Add new action type to `src/orchestrator/types.ts`
2. Implement validation in `src/orchestrator/validator.ts`
3. Add execution handler in `src/orchestrator/orchestrator.ts`
4. Update system prompt in `src/llm/system-prompt.ts`

### Adding New Game Support
1. Create game definition JSON in `public/games/`
2. Include: name, rules (plain text), initialState, soundEffects
3. No code changes needed - game logic lives in LLM context

### Modifying LLM Prompts
1. Edit `src/llm/system-prompt.ts`
2. Test with both Gemini and Ollama if possible
3. Keep prompts concise to reduce latency and cost

### Adjusting Voice Flows
1. Modify `src/orchestrator/orchestrator.ts` for main flow
2. Edit `src/orchestrator/name-collector.ts` for name collection
3. Update `src/wake-word.ts` for state machine changes

## Testing Commands

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run preview` - Preview production build
- `npm run lint` - Run ESLint
- `npm run lint:fix` - Auto-fix ESLint issues
- `npm run type-check` - Check TypeScript types

## Available Interfaces

- **Production**: `http://localhost:5173/` - Minimal pulsating orb
- **Debug**: `http://localhost:5173/debug.html` - Full console with logs

## Voice Interaction Flow

1. User says wake word: "Zookeeper"
2. System responds: "Listening for command..."
3. User speaks command (5 second window)
4. System transcribes and processes via LLM
5. Orchestrator validates and executes primitives
6. System narrates response via TTS
7. Returns to listening for wake word

## Known Patterns in Codebase

### Hybrid Deterministic Rules
Some game rules are enforced by the orchestrator (e.g., ladder/snake moves in Snakes & Ladders) rather than trusting the LLM. This is done for:
- 100% reliability
- Faster execution
- Cost reduction
- Silent error correction

See `checkAndApplyBoardMoves` in `orchestrator.ts` for implementation.

### Error Recovery
- Validation failures should provide voice feedback (voice-only UX)
- Processing errors should reset to idle state
- Model download failures need user-friendly recovery

### State Persistence
- App always starts fresh (SETUP phase) on launch
- Current session state is in-memory only

## Architecture Decisions

### Why Vosk?
- Completely free and offline
- No API limits or costs
- Both wake word and full STT
- Ideal for families

### Why LLM Swappability?
- Gemini: Fast (1-3s), low cost, cloud-based
- Ollama: Slow (30-50s), free, fully local
- Users choose based on needs

### Why In-Memory State (for now)?
- Simple and fast
- No persistence complexity

### Why Processing Lock?
- Prevents overlapping LLM requests
- Ensures deterministic state updates
- Avoids race conditions
- Better UX (no confusing parallel responses)
