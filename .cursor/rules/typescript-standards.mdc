---
description: TypeScript best practices and type safety requirements
globs: "**/*.ts"
---

# TypeScript Standards

## Strict Mode Requirements

- Use TypeScript in strict mode (ES2022)
- Enable all compiler warnings
- Fix all type errors before committing
- Run `npm run type-check` regularly

## Type Safety Best Practices

### Avoid `any`
- ❌ Never use `any` in production code
- ✅ Use proper types or `unknown` with type guards
- ✅ Create interfaces for complex structures

### Proper Error Handling
```typescript
try {
  // risky operation
} catch (error) {
  if (error instanceof Error) {
    logger.error('Operation failed', error.message)
  }
}
```

### Type Guards
```typescript
function isValidAction(action: unknown): action is PrimitiveAction {
  return (
    typeof action === 'object' &&
    action !== null &&
    'action' in action
  )
}
```

### Interface Over Type for Objects
```typescript
// ✅ Preferred
interface GameState {
  phase: GamePhase
  turn: string
}

// ❌ Avoid for object shapes
type GameState = {
  phase: GamePhase
  turn: string
}
```

## Testing Standards

Test files (`*.test.ts`) have pragmatic flexibility:

### What's Allowed in Tests
- ✅ `any` for mock implementations and test fixtures
- ✅ `as unknown as Type` for partial mocks
- ✅ `@ts-nocheck` for adversarial/malformed data tests
- ✅ `/* eslint-disable */` for intentional test patterns
- ✅ Global object mocking (e.g., `globalThis.fetch`, `globalThis.window`)
- ✅ Type assertions for simplified test setup

### Philosophy
- Tests should be readable and maintainable
- Don't die on strict typing hills in tests - use pragmatic solutions
- Focus type safety efforts on production code
- Adversarial tests (testing invalid data) may skip type checking entirely

## Common Patterns

### Path-Based State Access
```typescript
const value = stateManager.get('players.p1.position')
// Returns: unknown (must validate/cast)
```

### State Mutations (Orchestrator Only)
```typescript
await stateManager.set('players.p1.position', newPosition)
// Only called from orchestrator
```

### LLM Client Interface
```typescript
interface LLMClient {
  generateResponse(
    systemPrompt: string,
    userMessage: string
  ): Promise<string>
}
```
